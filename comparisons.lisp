(in-package :SCREAMER)

(defun ?integerp-internal (x)
  (cond ((null x) T)
        ((and (consp x) (cdr x))
         (andv (?integerp-internal (car x))
               (?integerp-internal (cdr x))))
        ((consp x) (?integerp-internal (car x)))
        (T (integerpv x))))
(defun ?integerp (x)
  (?integerp-internal (?xs-in x)))
(defun ?realp-internal (x)
  (cond ((null x) nil)
        ((and (consp x) (cdr x))
         (andv (?realp-internal (car x))
               (?realp-internal (cdr x))))
        ((consp x) (?realp-internal (car x)))
        (T (realpv x))))
(defun ?realp (x)
  (?realp-internal (?xs-in x)))
(defun ?numberp-internal (x)
  (cond ((null x) nil)
        ((and (consp x) (cdr x))
         (andv (?numberp-internal (car x))
               (?numberp-internal (cdr x))))
        ((consp x) (?numberp-internal (car x)))
        (T (numberpv x))))
(defun ?numberp (x)
  (?numberp-internal (?xs-in x)))
(defun ?booleanp-internal (x)
  (cond ((null x) nil)
        ((and (consp x) (cdr x))
         (andv (?booleanp-internal (car x))
               (?booleanp-internal (cdr x))))
        ((consp x) (?booleanp-internal (car x)))
        (T (booleanpv x))))
(defun ?booleanp (x) 
  (?booleanp-internal (?xs-in x)))
(defun ?member-internal (x sequence)
  (cond ((null x) (memberv nil sequence))
        ((and (consp x) (cdr x))
         (andv (?member-internal (car x) sequence)
               (?member-internal (cdr x) sequence)))
        ((consp x) (?member-internal (car x) sequence))
        (T (memberv x sequence))))
(defun ?member (x sequence) 
  (?member-internal (?xs-in x) sequence))
(defun !member-internal (x sequence)
  (cond ((null x) (notv (memberv nil sequence)))
        ((and (consp x) (cdr x))
         (andv (!member-internal (car x) sequence)
               (!member-internal (cdr x) sequence)))
        ((consp x) (!member-internal (car x) sequence))
        (T (notv (memberv x sequence)))))
(defun !member (x sequence) 
  (!member-internal (?xs-in x) sequence))
(defun one?= (x sequence)
  (cond
   ((null sequence) nil)
   (T (orv (=v x (car sequence))
           (one?= x (cdr sequence))))))
(defun not-one?= (x sequence)
  (cond
   ((null sequence) T)
   (T (andv (/=v x (car sequence))
           (not-one?= x (cdr sequence))))))
(defun ?=member-internal (x sequence)
  (cond ((null x) T)
        ((and (consp x) (cdr x))
         (andv (?=member-internal (car x) sequence)
               (?=member-internal (cdr x) sequence)))
        ((consp x) (?=member-internal (car x) sequence))
        (T (one?= x sequence))))
(defun ?=member (x sequence) (?=member-internal (?xs-in x) sequence))
(defun ?/=any-internal (x sequence)
  (cond ((null x) nil)
        ((and (consp x) (cdr x))
         (andv (?/=any-internal (car x) sequence)
               (?/=any-internal (cdr x) sequence)))
        ((consp x) (?/=any-internal (car x) sequence))
        (T (not-one?= x sequence))))
(defun ?/=any (x sequence) (?/=any-internal (?xs-in x) sequence))
(defun ?comparison-arguments (x list) (flatt (append (list x) list)))
(defun ?< (x &rest xs) (apply #'<v (?oper-arguments x xs)))
(defun ?> (x &rest xs) (apply #'>v (?oper-arguments x xs)))
(defun ?<= (x &rest xs) (apply #'<=v (?oper-arguments x xs)))
(defun ?>= (x &rest xs) (apply #'>=v (?oper-arguments x xs)))
(defun ?= (x &rest xs) (apply #'=v (?oper-arguments x xs)))
(defun ?/= (x &rest xs) (apply #'/=v (?oper-arguments x xs)))
(defun ?max (x &rest xs) (apply #'maxv (?xs-in (append (list x) xs))))
(defun ?min (x &rest xs) (apply #'minv (?xs-in (append (list x) xs))))
(defun ?and (x y &rest ys) (apply #'andv (append (list x y) ys)))
(defun ?or (x y &rest ys) (apply #'orv (append (list x y) ys)))
(defun ?not (x) (notv x))
(defun ?equal (x y) (equalv x y))

(defun all?different-internal (x xs)
  (if (null xs)
      t
    (andv (/=v x (car xs))
          (all?different-internal x (cdr xs))
          (all?different-internal (car xs) (cdr xs)))))

(defun all?different (x &rest xs)
  ;; (copied from screamer docs) Functionally the same as (apply #'/=v list), but faster.
  (let ((variables (?xs-in (append (list x) xs))))
    (all?different-internal (car variables) (cdr variables))))

(defun ?between-internal (x min max)
  (cond ((null x) T)
        ((and (consp x) (cdr x))
         (andv (?between-internal (car x) min max)
               (?between-internal (cdr x) min max)))
        ((consp x) (?between-internal (car x) min max))
        ((and min max) (<=v min x max))
        (min (>=v x min))
        (max (<=v x max))
        (T T)))

(defun ?between (input min max)
  (?between-internal (?xs-in input) min max))

(defun ?list<-internal (x value) (if x (andv (<v (car x) value) (?list< (cdr x) value)) T))
(defun ?list< (x value) (?list<-internal (?xs-in x) value))
(defun ?list<=-internal (x value) (if x (andv (<=v (car x) value) (?list<= (cdr x) value)) T))
(defun ?list<= (x value) (?list<=-internal (?xs-in x) value))
(defun ?list>-internal (x value) (if x (andv (>v (car x) value) (?list> (cdr x) value)) T))
(defun ?list> (x value) (?list>-internal (?xs-in x) value))
(defun ?list>=-internal (x value) (if x (andv (>=v (car x) value) (?list>= (cdr x) value)) T))
(defun ?list>= (x value) (?list>=-internal (?xs-in x) value))
(defun ?list=-internal (x value) (if x (andv (=v (car x) value) (?list= (cdr x) value)) T))
(defun ?list= (x value) (?list=-internal (?xs-in x) value))
(defun ?list/=-internal (x value) (if x (andv (/=v (car x) value) (?list/= (cdr x) value)) T))
(defun ?list/= (x value) (?list/=-internal (?xs-in x) value))

(defun ?lists= (xs ys)
  (cond ((and (null xs) (null ys)) T)
        ((or (null xs) (null ys)) nil)
        ((and (consp xs) (consp ys))
         (andv (?lists= (car xs) (car ys))
               (?lists= (cdr xs) (cdr ys))))
        ((or (consp xs) (consp ys)) nil)
        (T (=v xs ys))))

(defun ?lists/= (xs ys)
  (cond ((and (null xs) (null ys)) T)
        ((or (null xs) (null ys)) nil)
        ((and (consp xs) (consp ys))
         (andv (?lists= (car xs) (car ys))
               (?lists= (cdr xs) (cdr ys))))
        ((or (consp xs) (consp ys)) nil)
        (T (/=v xs ys))))


